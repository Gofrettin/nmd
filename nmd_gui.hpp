// This is a C++ retained mode graphical user interface library.
//
// define the 'NMD_GUI_IMPLEMENTATION' macro in one and only one source file.
//
// High level overview:
// The scene generated by this gui is composed of layers represented by Gui::Layer. Layers can contain
// widgets(e.g. button, checkboxes and text inputs) including other layers and can be placed in front or behind
// another layer. It's possible to handle various events related to a widget by registring an event callback using
// RegisterEventCallback() from a class that inherents from Widget.
//
// Low level overview:
// The Gui::Context(acessible by Gui::GetContext()) global variable holds the state of the entire gui, it
// contains a Gui::DrawList variable(the only used by the gui) which holds a vertex buffer and an index buffer.
// The Gui::DrawList class has methods to draw basic geometry shapes(e.g. circles, rectangles and lines), in order
// to use these methods you have to call them from an event callback of type EVENT_PRE_RENDER or EVENT_POST_RENDER,
// you do this by calling RegisterEventCallback() from a class that inherets from Widget(e.g. Gui::Layer).
//
// Supported rendering APIs: Direct3D 9(D3D9), Direct3D 11(D3D11).
// To use a specific rendering api define the macro 'NMD_GUI_{RENDERING API}' before including "nmd_gui.hpp".
//
// Usage:
//  - Always:
//     - Call Gui::Render() once per frame to calculate the triangles's vertices and indices.
//
//  - Windows:
//     - Call Gui::Win32Init() on initialization.
//     - Call Gui::WindowProc() in the window's procedure.
//
//  - D3D9:
//     - Call Gui::D3D9SetDevice() on initialization.
//     - Call Gui::D3D9Render() once per frame between IDirect3DDevice9::BeginScene() and
//       IDirect3DDevice9::EndScene() to actually render(draw) the scene.
//
//  - D3D11:
//     - Call Gui::D3D11SetDeviceContext() on initialization.
//     - Call Gui::D3D11Render() once per frame before IDXGISwapChain::Present() to actually
//       render(draw) the scene.
//
// Example:
// #include <...>
// #include <...>
// #define NMD_GUI_IMPLEMENTATION
// #define NMD_GUI_D3D9
// #include "nmd_gui.hpp"
//
//Credits:
// - imgui - https://github.com/ocornut/imgui
// - stb_truetype - https://github.com/nothings/stb/blob/master/stb_truetype.h
// - stb_image - https://github.com/nothings/stb/blob/master/stb_image.h

#ifndef NMD_GUI_H
#define NMD_GUI_H

//Common dependencies
#include <cinttypes>
#include <vector>
#include <unordered_map>
#include <memory>
#include <queue>

//You may use 'uint32_t' instead of 'const char*' if you preffer. It will likely improve performance.
typedef const char* IdentifierType;

//You may use uint32_t if uint16_t is not enough.
typedef uint16_t IndexType;

#ifdef _WIN32
#include <Windows.h>
#endif

#ifdef NMD_GUI_D3D9
#include <d3d9.h>
#pragma comment(lib, "d3d9.lib")
#endif

#ifdef NMD_GUI_D3D11
#include <d3d11.h>
#pragma comment(lib, "d3d11.lib")

#include <d3dcompiler.h>
#pragma comment(lib, "d3dcompiler.lib")
#endif

namespace Gui
{
#ifdef _WIN32
    void Win32Init(HWND hwnd);
    LRESULT WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#endif

#ifdef NMD_GUI_D3D9
    void D3D9SetDevice(LPDIRECT3DDEVICE9 pDevice);
    void D3D9Render();
#endif

#ifdef NMD_GUI_D3D11
    void D3D11SetDeviceContext(ID3D11DeviceContext* pDeviceContext);
    void D3D11Render();
#endif

    struct EventCallback;
    class Widget;
    class Layer;

    enum class WIDGET_TYPE
    {
        UNKNOWN,
        LAYER,
        BUTTON,
        CHECKBOX,
        LABEL,
        INPUT
    };

    struct Color
    {
        static const Color Black;
        static const Color White;
        static const Color Red;
        static const Color Green;
        static const Color Blue;
        static const Color Orange;
        static const Color Amber;
        static const Color AndroidGreen;
        static const Color Azure;
        static const Color Bronze;
        static const Color Corn;
        static const Color Emerald;
        static const Color LapisLazuli;
        static const Color Lava;

        union
        {
            uint32_t color;
            struct { uint8_t r, g, b, a; };
        };

        Color(uint32_t color)
            : color(color) {}

        Color(uint8_t r, uint8_t g, uint8_t b, uint8_t a)
            : r(r), g(g), b(b), a(a) {}

        Color() : Color(0) {}
    };

    struct Vec2
    {
        float x, y;

        Vec2() : x(0.0f), y(0.0f) {}
        Vec2(float x, float y) : x(x), y(y) {}
    };

    struct Vec3
    {
        float x, y, z;

        Vec3() : x(0.0f), y(0.0f), z(0.0f) {}
        Vec3(float x, float y, float z) : x(x), y(y), z(z) {}

        Vec3 operator+(const Vec3& other) { return Vec3(this->x + other.x, this->y + other.y, this->z + other.z); }
        void operator+=(const Vec3& other) { this->x += other.x; this->y += other.y; this->z += other.z; }
    };

    struct Vec4
    {
        union
        {
            struct { float x, y, z, w; };
            struct { float left, top, right, bottom; };
            struct { Vec2 pos, size; };
        };

        Vec4() : pos(), size() {}
        Vec4(float x, float y, float z, float w) : x(x), y(y), z(z), w(w) {}
        Vec4(const Vec2& pos, const Vec2& size) : pos(pos), size(size) {}

        Vec4 operator+(const Vec4& other) { return Vec4(this->x + other.x, this->y + other.y, this->z + other.z, this->w + other.w); }
        void operator+=(const Vec4& other) { this->x += other.x, this->y + other.y, this->z + other.z, this->w + other.w; }
    };

    bool IsPointInRect(const Vec4& rect, const Vec2& p);

    struct Style
    {
        uint32_t cornerFlags;
        float rounding;
    };

    struct Vertex
    {
        Vec2 pos;
        Color color;
        Vec2 uv;

        Vertex() : pos(), color(), uv() {}
        Vertex(const Vec2& pos, const Color& color, const Vec2& uv) : pos(pos), color(color), uv(uv) {}
    };

    enum CORNER_FLAGS
    {
        CORNER_FLAGS_NONE         = (1 << 0),
        CORNER_FLAGS_TOP_LEFT     = (1 << 1),
        CORNER_FLAGS_TOP_RIGHT    = (1 << 2),
        CORNER_FLAGS_BOTTOM_LEFT  = (1 << 3),
        CORNER_FLAGS_BOTTOM_RIGHT = (1 << 4),
        CORNER_FLAGS_ALL          = (1 << 5) - 1,
        CORNER_FLAGS_TOP          = CORNER_FLAGS_TOP_LEFT    | CORNER_FLAGS_TOP_RIGHT,
        CORNER_FLAGS_BOTTOM       = CORNER_FLAGS_BOTTOM_LEFT | CORNER_FLAGS_BOTTOM_RIGHT,
        CORNER_FLAGS_LEFT         = CORNER_FLAGS_TOP_LEFT    | CORNER_FLAGS_BOTTOM_LEFT,
        CORNER_FLAGS_RIGHT        = CORNER_FLAGS_TOP_RIGHT   | CORNER_FLAGS_BOTTOM_RIGHT
    };

    struct DrawListSharedData
    {
        Vec2 cachedCircleVertices12[12];
        uint8_t cachedCircleSegmentCounts64[64];

        DrawListSharedData();
        void CalculateCircleSegments(float maxError);
    };

    class DrawList
    {
        std::vector<Vec2> path;

        static const DrawListSharedData* const sharedData;
        
    public:
        DrawList() = default;
        DrawList(const DrawList&) = delete;

        std::vector<Vertex> vertices;
        std::vector<IndexType> indices;

        void AddLine(const Vec2& p1, const Vec2& p2, Color color, float thickness = 1.0f);
        
        void AddRect(const Vec2& p1, const Vec2& p2, Color color, float rounding = 0.0f, uint32_t cornerFlags = CORNER_FLAGS_ALL, float thickness = 1.0f);
        void AddRectFilled(const Vec2& p1, const Vec2& p2, Color color, float rounding = 0.0f, uint32_t cornerFlags = CORNER_FLAGS_ALL);
        void AddRectFilledMultiColor(const Vec2& p1, const Vec2& p2, Color colorUpperLeft, Color colorUpperRight, Color colorBottomRight, Color colorBottomLeft);
       
        void AddQuad(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Vec2& p4, Color color, float thickness = 1.0f);
        void AddQuadFilled(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Vec2& p4, Color color);
        
        void AddTriangle(const Vec2& p1, const Vec2& p2, const Vec2& p3, Color color, float thickness = 1.0f);
        void AddTriangleFilled(const Vec2& p1, const Vec2& p2, const Vec2& p3, Color color);
        
        //Set numSegments to zero(0) if you want the function to automatically determine the number of segmnts.
        void AddCircle(const Vec2& p, float radius, Color color, size_t numSegments = 12, float thickness = 1.0f);
        void AddCircleFilled(const Vec2& p, float radius, Color color, size_t numSegments = 12);
        
        void AddNgon(const Vec2& center, float radius, Color color, size_t numSegments, float thickness = 1.0f);
        void AddNgonFilled(const Vec2& center, float radius, Color color, size_t numSegments);
       
        void AddPolyline(const Vec2* points, size_t numPoints, Color color, bool closed = false, float thickness = 1.0f);
        void AddConvexPolyFilled(const Vec2* points, size_t numPoints, Color color);

        inline void PathLineTo(const Vec2& pos) { path.push_back(pos); }
        void PathRect(const Vec2& p1, const Vec2& p2, float rounding, uint32_t rounding_corners);
        
        //startAtCenter places the first vertex at the center, this can be used to create a pie chart when using PathFillConvex().
        void PathArcTo(const Vec2& center, float radius, float startAngle, float endAngle, size_t numSegments = 10, bool startAtCenter = false);

        //startAtCenter places the first vertex at the center, this can be used to create a pie chart when using PathFillConvex().
        //This functions uses twelve(12) chached vertices initialized during startup, it should be faster than PathArcTo.
        void PathArcToCached(const Vec2& center, float radius, size_t startAngleOf12, size_t endAngleOf12, bool startAtCenter = false);

        inline void PathStroke(Color color, bool closed, float thickness = 1.0f) { AddPolyline(path.data(), path.size(), color, closed, thickness); path.clear(); }
        inline void PathFillConvex(Color color) { AddConvexPolyFilled(path.data(), path.size(), color); path.clear(); }

        void PrimRect(const Vec2& p1, const Vec2& p2, Color color);
    };

    struct IO
    {
        struct MouseUpEvent
        {
            int key;
            Vec2 pos;

            MouseUpEvent(int key, const Vec2& pos) : key(key), pos(pos) {}
        };


        Vec2 displaySize;

        Vec2 lastMousePos, mousePos;
        bool mouseDown[5];
        float mouseWheel;
        float mouseWheelH;
        bool keyStates[256];

        Vec2 mouseClickedPos[5]; //Mouse's position when the button was last clicked

        std::vector<uint16_t> charatersQueue;
        std::queue<MouseUpEvent> mouseUpQueue;
        MouseUpEvent* firstMouseUpEvent;

        bool IsAnyMouseDown();
        void AddInputCharacter(uint16_t c);
    };

    struct Context
    {
        DrawList drawList;
        DrawListSharedData drawListSharedData;

        std::unordered_map<IdentifierType, Layer> layers;
        std::vector<Layer*> layersStack;
        std::unordered_map<IdentifierType, Style> styles;

        IO io;
    };

    enum EVENT_TYPE
    {
        EVENT_UNKNOWN      = 0,
        EVENT_MOUSE_CLICK  = (1 <<  0),
        EVENT_MOUSE_HOVER  = (1 <<  1),
        EVENT_MOUSE_ENTER  = (1 <<  2),
        EVENT_MOUSE_LEAVE  = (1 <<  3),
        EVENT_MOUSE_DOWN   = (1 <<  4),
        EVENT_MOUSE_UP     = (1 <<  5),
        EVENT_MOUSE_SCROLL = (1 <<  6),
        EVENT_KEY_DOWN     = (1 <<  7),
        EVENT_KEY_UP       = (1 <<  8),
        EVENT_KEY_CHAR     = (1 <<  9),
        EVENT_PRE_RENDER   = (1 << 10),
        EVENT_POST_RENDER  = (1 << 11)
    };

    struct Event
    {
        uint32_t type;
        Widget* widget;
        Vec2 position;
        uint16_t key;

        Event(EVENT_TYPE type, Widget* widget, const Vec2& position, uint16_t key)
            : type(type),
            widget(widget),
            position(position),
            key(key) {}
        Event() : Event(EVENT_UNKNOWN, nullptr, Vec2(), 0) {}
    };

    class Widget
    {
    private:
        bool mouseOver, wasMouseOver;

    protected:
        std::vector<EventCallback> m_eventCallbacks;

    public:
        //WIDGET_TYPE widgetType;
        bool active;
        bool visible;
        Vec4 rect;
        Color backgroundColor;
        Style* style;

        const Widget* const parent;

        Widget(const Widget* const parent)
            : parent(parent),
            active(false),
            visible(true),
            rect(),
            backgroundColor(),
            mouseOver(false), wasMouseOver(false),
            style(nullptr) {}

        void RegisterEventCallback(EVENT_TYPE eventType, void(*callback)(const Event&));
        void UnregisterEventCallback(void(*callback)(const Event&));
        const std::vector<EventCallback>& GetEventCallbacks() const { return m_eventCallbacks; }

        virtual void Render() = 0;
        virtual void Notify();
    };

    struct EventCallback
    {
        EVENT_TYPE type;
        void(*callback)(const Event&);

        EventCallback() : type(EVENT_UNKNOWN), callback(nullptr) {};
        EventCallback(EVENT_TYPE type, void(*callback)(const Event&)) : type(type), callback(callback) {};
    };

    struct Button : Widget
    {
        const char* text;

        Button(const Widget* const parent) : Widget(parent), text(nullptr) {}
        Button(const Widget* const parent, const char* text) : Widget(parent), text(text) {}

        void Render();
    };

    struct CheckBox : Widget
    {
        bool* checked;

        CheckBox(const Widget* const parent) : Widget(parent), checked(nullptr) {}
        CheckBox(const Widget* const parent, bool* checked) : Widget(parent), checked(checked) {}

        void Render();
    };

    class Layer : public Widget
    {
        std::unordered_map<IdentifierType, Widget*> m_widgets;
    public:
        Layer() : Layer(nullptr) {}
        Layer(const Widget* const parent) : Widget(parent) {}

        void MoveToTop(bool fixLayer = false);
        void MoveToBottom(bool fixLayer = false);

        inline Widget* GetWidget(IdentifierType widgetId) { return m_widgets[widgetId]; };

        Button* AddButton(IdentifierType buttonId, const char* text, Style* style);
        CheckBox* AddCheckBox(IdentifierType checkBoxId, bool* checked);

        void Render();
    };

    Layer* GetTopLayer();
    Layer* GetBottomLayer();

    Layer* GetLayer(IdentifierType layerId);

    Style* GetStyle(IdentifierType styleId);

    Context* GetContext();

    void Render();

    bool KeyUp();

#define GUI_PI 3.141592653f
#define GUI_2PI 6.2831853f
#define GUI_MIN(a, b) (a < b ? a : b)

#ifdef NMD_GUI_IMPLEMENTATION
    static Context g_context;

    const DrawListSharedData* const DrawList::sharedData = &g_context.drawListSharedData;

    DrawListSharedData::DrawListSharedData()
    {
        for (size_t i = 0; i < 12; i++)
        {
            //const float angle = (static_cast<float>(i) / 12.0f) * GUI_2PI;
            const float angle = (static_cast<float>(i) / 6.0f) * GUI_PI; // Simplified version of the line above.
            cachedCircleVertices12[i] = Vec2(cosf(angle), sinf(angle));
        }

        CalculateCircleSegments(1.6f);
    }

    template<typename T> static inline T Clamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }
    static inline Vec2 Clamp(const Vec2& v, const Vec2& mn, Vec2 mx) { return Vec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }
#define CIRCLE_AUTO_SEGMENT_MIN 12
#define CIRCLE_AUTO_SEGMENT_MAX 512
#define CIRCLE_AUTO_SEGMENT_CALC(radius, maxError) (Clamp(static_cast<size_t>(GUI_2PI / acosf((radius - maxError) / radius)), static_cast<size_t>(CIRCLE_AUTO_SEGMENT_MIN), static_cast<size_t>(CIRCLE_AUTO_SEGMENT_MAX)))

    void DrawListSharedData::CalculateCircleSegments(float maxError)
    {
        for (size_t i = 0; i < 64; i++)
        {
            const int segment_count = CIRCLE_AUTO_SEGMENT_CALC(i + 1.0f, maxError);
            cachedCircleSegmentCounts64[i] = GUI_MIN(segment_count, 255);
        }
    }

#ifdef _WIN32
    static HWND g_hwnd;

    void Win32Init(HWND hwnd)
    {
        g_hwnd = hwnd;
    }

    void Win32NewFrame()
    {
        RECT rect;
        GetClientRect(g_hwnd, &rect);
        g_context.io.displaySize = Vec2(static_cast<float>(rect.right - rect.left), static_cast<float>(rect.bottom - rect.top));
    }

    LRESULT WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        case WM_MOUSEMOVE:
            g_context.io.lastMousePos = g_context.io.mousePos;
            g_context.io.mousePos = Vec2(static_cast<float>(lParam & 0xffff), static_cast<float>(lParam >> 16));
            break;
        case WM_LBUTTONDOWN: case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDOWN: case WM_RBUTTONDBLCLK:
        case WM_MBUTTONDOWN: case WM_MBUTTONDBLCLK:
        case WM_XBUTTONDOWN: case WM_XBUTTONDBLCLK:
        {
            int button = 0;
            if (uMsg == WM_LBUTTONDOWN || uMsg == WM_LBUTTONDBLCLK) { button = 0; }
            else if (uMsg == WM_RBUTTONDOWN || uMsg == WM_RBUTTONDBLCLK) { button = 1; }
            else if (uMsg == WM_MBUTTONDOWN || uMsg == WM_MBUTTONDBLCLK) { button = 2; }
            else if (uMsg == WM_XBUTTONDOWN || uMsg == WM_XBUTTONDBLCLK) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 3 : 4; }
            g_context.io.mouseDown[button] = true;

            g_context.io.mouseClickedPos[button] = Vec2(static_cast<float>(lParam & 0xffff), static_cast<float>(lParam >> 16));
            break;
        }
        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_MBUTTONUP:
        case WM_XBUTTONUP:
        {
            int button = 0;
            if (uMsg == WM_LBUTTONUP) { button = 0; }
            else if (uMsg == WM_RBUTTONUP) { button = 1; }
            else if (uMsg == WM_MBUTTONUP) { button = 2; }
            else if (uMsg == WM_XBUTTONUP) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 3 : 4; }
            g_context.io.mouseDown[button] = false;
            g_context.io.mouseUpQueue.emplace(button, g_context.io.mousePos);
            break;
        }
        case WM_MOUSEWHEEL:
            g_context.io.mouseWheel += (float)GET_WHEEL_DELTA_WPARAM(wParam) / (float)WHEEL_DELTA;
            break;
        case WM_MOUSEHWHEEL:
            g_context.io.mouseWheelH += (float)GET_WHEEL_DELTA_WPARAM(wParam) / (float)WHEEL_DELTA;
            break;
        case WM_KEYDOWN:
        case WM_SYSKEYDOWN:
            g_context.io.keyStates[wParam] = true;
            break;
        case WM_KEYUP:
        case WM_SYSKEYUP:
            g_context.io.keyStates[wParam] = false;
            break;
        case WM_CHAR:
            g_context.io.AddInputCharacter(static_cast<uint16_t>(wParam));
            break;
        }

        return 0;
    }

#endif

#ifdef NMD_GUI_D3D9
    static LPDIRECT3DDEVICE9 g_pD3D9Device = nullptr;
    static LPDIRECT3DVERTEXBUFFER9 g_pD3D9VertexBuffer = nullptr;
    static LPDIRECT3DINDEXBUFFER9 g_pD3D9IndexBuffer = nullptr;
    //static LPDIRECT3DTEXTURE9 g_pFontTexture = nullptr;
    static size_t g_D3D9VertexBufferSize, g_D3D9IndexBufferSize;

    struct CustomVertex
    {
        Vec3 pos;
        D3DCOLOR color;
        Vec2 uv;

        CustomVertex() : pos(), color(), uv() {}
        CustomVertex(const Vec3& pos, D3DCOLOR color, const Vec2& uv) : pos(pos), color(color), uv(uv) {}

        static DWORD FVF;
    };

    DWORD CustomVertex::FVF = (D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1);

    void D3D9SetDevice(LPDIRECT3DDEVICE9 pD3D9Device) { g_pD3D9Device = pD3D9Device; }

    void D3D9SetupRenderState()
    {
        
    }

    void D3D9Render()
    {
        if (g_context.io.displaySize.x <= 0.0f || g_context.io.displaySize.y <= 0.0f)
            return;

        if (!g_pD3D9VertexBuffer || g_D3D9VertexBufferSize < g_context.drawList.vertices.size())
        {
            if (g_pD3D9VertexBuffer)
                g_pD3D9VertexBuffer->Release(), g_pD3D9VertexBuffer = NULL;

            g_D3D9VertexBufferSize = g_context.drawList.vertices.size() + 5000;
            if (g_pD3D9Device->CreateVertexBuffer(static_cast<UINT>(g_D3D9VertexBufferSize * sizeof(CustomVertex)), D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY, CustomVertex::FVF, D3DPOOL_DEFAULT, &g_pD3D9VertexBuffer, NULL) != D3D_OK)
                return;
        }

        if (!g_pD3D9IndexBuffer || g_D3D9IndexBufferSize < g_context.drawList.indices.size())
        {
            if (g_pD3D9IndexBuffer)
                g_pD3D9IndexBuffer->Release(), g_pD3D9IndexBuffer = NULL;

            g_D3D9IndexBufferSize = g_context.drawList.indices.size() + 10000;
            if (g_pD3D9Device->CreateIndexBuffer(static_cast<UINT>(g_D3D9IndexBufferSize * sizeof(IndexType)), D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY, sizeof(IndexType) == 2 ? D3DFMT_INDEX16 : D3DFMT_INDEX32, D3DPOOL_DEFAULT, &g_pD3D9IndexBuffer, NULL) < 0)
                return;
        }

        IDirect3DStateBlock9* stateBlock;
        if (g_pD3D9Device->CreateStateBlock(D3DSBT_ALL, &stateBlock) != D3D_OK)
            return;

        D3DMATRIX lastWorldTransform, lastViewTransform, lastProjectionTransform;
        g_pD3D9Device->GetTransform(D3DTS_WORLD, &lastWorldTransform);
        g_pD3D9Device->GetTransform(D3DTS_VIEW, &lastViewTransform);
        g_pD3D9Device->GetTransform(D3DTS_PROJECTION, &lastProjectionTransform);

        CustomVertex* pVertex; IndexType* pIndices;
        if (g_pD3D9VertexBuffer->Lock(0, static_cast<UINT>(g_context.drawList.vertices.size() * sizeof(CustomVertex)), reinterpret_cast<void**>(&pVertex), D3DLOCK_DISCARD) != D3D_OK ||
            g_pD3D9IndexBuffer->Lock(0, static_cast<UINT>(g_context.drawList.indices.size() * sizeof(IndexType)), reinterpret_cast<void**>(&pIndices), D3DLOCK_DISCARD) != D3D_OK)
            return;

        //Copy vertices
        size_t i = 0;
        for (auto& vertex : g_context.drawList.vertices)
            pVertex[i++] = CustomVertex(Vec3(vertex.pos.x, vertex.pos.y, 0.0f), D3DCOLOR_ARGB(vertex.color.a, vertex.color.r, vertex.color.g, vertex.color.b), vertex.uv);

        //Copy indices.
        memcpy(pIndices, g_context.drawList.indices.data(), g_context.drawList.indices.size() * sizeof(IndexType));

        g_pD3D9VertexBuffer->Unlock(), g_pD3D9IndexBuffer->Unlock();

        //Set render state
        {
            g_pD3D9Device->SetStreamSource(0, g_pD3D9VertexBuffer, 0, sizeof(CustomVertex));
            g_pD3D9Device->SetIndices(g_pD3D9IndexBuffer);
            g_pD3D9Device->SetFVF(CustomVertex::FVF);
            g_pD3D9Device->SetPixelShader(NULL);
            g_pD3D9Device->SetVertexShader(NULL);
            g_pD3D9Device->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
            g_pD3D9Device->SetRenderState(D3DRS_LIGHTING, false);
            g_pD3D9Device->SetRenderState(D3DRS_ZENABLE, false);
            g_pD3D9Device->SetRenderState(D3DRS_ALPHABLENDENABLE, true);
            g_pD3D9Device->SetRenderState(D3DRS_ALPHATESTENABLE, false);
            g_pD3D9Device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
            g_pD3D9Device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
            g_pD3D9Device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
            g_pD3D9Device->SetRenderState(D3DRS_SCISSORTESTENABLE, true);
            g_pD3D9Device->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
            g_pD3D9Device->SetRenderState(D3DRS_FOGENABLE, false);
            g_pD3D9Device->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
            g_pD3D9Device->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
            g_pD3D9Device->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
            g_pD3D9Device->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
            g_pD3D9Device->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
            g_pD3D9Device->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
            g_pD3D9Device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
            g_pD3D9Device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);

            float L = 0.5f;
            float R = g_context.io.displaySize.x + 0.5f;
            float T = 0.5f;
            float B = g_context.io.displaySize.y + 0.5f;
            D3DMATRIX mat_identity = { { { 1.0f, 0.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f, 0.0f,  0.0f, 0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 0.0f, 1.0f } } };
            D3DMATRIX mat_projection =
            { { {
                2.0f / (R - L),   0.0f,         0.0f,  0.0f,
                0.0f,         2.0f / (T - B),   0.0f,  0.0f,
                0.0f,         0.0f,         0.5f,  0.0f,
                (L + R) / (L - R),  (T + B) / (B - T),  0.5f,  1.0f
            } } };
            g_pD3D9Device->SetTransform(D3DTS_WORLD, &mat_identity);
            g_pD3D9Device->SetTransform(D3DTS_VIEW, &mat_identity);
            g_pD3D9Device->SetTransform(D3DTS_PROJECTION, &mat_projection);
        }

        g_pD3D9Device->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, static_cast<UINT>(g_context.drawList.vertices.size()), 0, static_cast<UINT>(g_context.drawList.indices.size() / 3));

        g_pD3D9Device->SetTransform(D3DTS_WORLD, &lastWorldTransform);
        g_pD3D9Device->SetTransform(D3DTS_VIEW, &lastViewTransform);
        g_pD3D9Device->SetTransform(D3DTS_PROJECTION, &lastProjectionTransform);

        stateBlock->Apply();
        stateBlock->Release();
    }
#endif

#ifdef NMD_GUI_D3D11
    static ID3D11Device* g_pD3D11Device = NULL;
    static ID3D11DeviceContext* g_pD3D11DeviceContext = NULL;
    static ID3D11Buffer* g_pD3D11VertexBuffer = NULL;
    static ID3D11Buffer* g_pD3D11IndexBuffer = NULL;
    static size_t g_D3D11VertexBufferSize = 0, g_D3D11IndexBufferSize = 0;
    static ID3DBlob* g_pD3D11ShaderBlob = NULL;
    static ID3D11VertexShader* g_pD3D11VertexShader = NULL;
    static ID3D11PixelShader* g_pD3D11PixelShader = NULL;
    static ID3D11InputLayout* g_pD3D11InputLayout = NULL;
    static ID3D11Buffer* g_pD3D11VertexConstantBuffer = NULL;

    void D3D11SetDeviceContext(ID3D11DeviceContext* pD3D11DeviceContext)
    {
        g_pD3D11DeviceContext = pD3D11DeviceContext;
        g_pD3D11DeviceContext->GetDevice(&g_pD3D11Device);
    }

    void D3D11Render()
    {
        struct VERTEX_CONSTANT_BUFFER { float mvp[4][4]; };

        if (g_context.io.displaySize.x <= 0.0f || g_context.io.displaySize.y <= 0.0f)
            return;

        if (!g_pD3D11VertexShader)
        {
            const char* const pixelShaderCode = "\
            struct PS_INPUT { float4 pos : SV_POSITION; float4 color : COLOR0; };\
            float4 main(PS_INPUT ps_input) : SV_TARGET\
            {\
                return ps_input.color;\
            }";

            if (D3DCompile(pixelShaderCode, strlen(pixelShaderCode), NULL, NULL, NULL, "main", "ps_4_0", 0, 0, &g_pD3D11ShaderBlob, NULL) != S_OK)
                return;

            if (g_pD3D11Device->CreatePixelShader(g_pD3D11ShaderBlob->GetBufferPointer(), g_pD3D11ShaderBlob->GetBufferSize(), NULL, &g_pD3D11PixelShader) != S_OK)
                return;

            const char* const vertexShaderCode = "\
            cbuffer vertexBuffer : register(b0) { float4x4 projectionMatrix; };\
            struct VS_INPUT { float2 pos : POSITION; float4 color : COLOR0; };\
            struct PS_INPUT { float4 pos : SV_POSITION; float4 color : COLOR0; };\
            PS_INPUT main(VS_INPUT vs_input)\
            {\
                PS_INPUT ps_input;\
                ps_input.pos = mul(projectionMatrix, float4(vs_input.pos.xy, 0.0f, 1.0f));\
                ps_input.color = vs_input.color;\
                return ps_input;\
            }";

            if (D3DCompile(vertexShaderCode, strlen(vertexShaderCode), NULL, NULL, NULL, "main", "vs_4_0", 0, 0, &g_pD3D11ShaderBlob, NULL) != S_OK)
                return;

            if (g_pD3D11Device->CreateVertexShader(g_pD3D11ShaderBlob->GetBufferPointer(), g_pD3D11ShaderBlob->GetBufferSize(), NULL, &g_pD3D11VertexShader) != S_OK)
                return;

            D3D11_INPUT_ELEMENT_DESC inputs[] = {
                { "POSITION", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
                { "COLOR", 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, 8, D3D11_INPUT_PER_VERTEX_DATA, 0 },
            };
            if(g_pD3D11Device->CreateInputLayout(inputs, 2, g_pD3D11ShaderBlob->GetBufferPointer(), g_pD3D11ShaderBlob->GetBufferSize(), &g_pD3D11InputLayout) != S_OK)
                return;

            g_pD3D11ShaderBlob->Release();

            D3D11_BUFFER_DESC desc;
            desc.ByteWidth = sizeof(VERTEX_CONSTANT_BUFFER);
            desc.Usage = D3D11_USAGE_DYNAMIC;
            desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
            desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
            desc.MiscFlags = 0;
            g_pD3D11Device->CreateBuffer(&desc, NULL, &g_pD3D11VertexConstantBuffer);
        }

        if (!g_pD3D11VertexBuffer || g_D3D11VertexBufferSize < g_context.drawList.vertices.size())
        {
            if (g_pD3D11VertexBuffer)
                g_pD3D11VertexBuffer->Release(), g_pD3D11VertexBuffer = nullptr;

            g_D3D11VertexBufferSize = g_context.drawList.vertices.size() + 5000;

            D3D11_BUFFER_DESC desc;
            desc.Usage = D3D11_USAGE_DYNAMIC;
            desc.ByteWidth = g_D3D11VertexBufferSize * sizeof(Vertex);
            desc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
            desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
            desc.MiscFlags = 0;

            if (g_pD3D11Device->CreateBuffer(&desc, NULL, &g_pD3D11VertexBuffer) != S_OK)
                return;
        }

        if (!g_pD3D11IndexBuffer || g_D3D11IndexBufferSize < g_context.drawList.indices.size())
        {
            if (g_pD3D11IndexBuffer)
                g_pD3D11IndexBuffer->Release(), g_pD3D11IndexBuffer = nullptr;

            g_D3D11IndexBufferSize = g_context.drawList.indices.size() + 10000;

            D3D11_BUFFER_DESC desc;
            desc.Usage = D3D11_USAGE_DYNAMIC;
            desc.ByteWidth = g_D3D11IndexBufferSize * sizeof(IndexType);
            desc.BindFlags = D3D11_BIND_INDEX_BUFFER;
            desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
            desc.MiscFlags = 0;

            if (g_pD3D11Device->CreateBuffer(&desc, NULL, &g_pD3D11IndexBuffer) != S_OK)
                return;
        }

        D3D11_MAPPED_SUBRESOURCE mappedResource = { NULL, 0, 0 };
        if (g_pD3D11DeviceContext->Map(g_pD3D11VertexBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource) != S_OK)
            return;
        size_t i = 0;
        for (auto& vertex : g_context.drawList.vertices)
            memcpy(reinterpret_cast<uint8_t*>(mappedResource.pData) + i * 12, &vertex, 12), i++;
        g_pD3D11DeviceContext->Unmap(g_pD3D11VertexBuffer, 0);

        if (g_pD3D11DeviceContext->Map(g_pD3D11IndexBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource) != S_OK)
            return;
        memcpy(mappedResource.pData, g_context.drawList.indices.data(), sizeof(IndexType) * g_context.drawList.indices.size());
        g_pD3D11DeviceContext->Unmap(g_pD3D11IndexBuffer, 0);

        if (g_pD3D11DeviceContext->Map(g_pD3D11VertexConstantBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource) != S_OK)
            return;
        VERTEX_CONSTANT_BUFFER* constant_buffer = (VERTEX_CONSTANT_BUFFER*)mappedResource.pData;
        const float L = 0.0f;
        const float R = 0.0 + g_context.io.displaySize.x;
        const float T = 0.0;
        const float B = 0.0 + g_context.io.displaySize.y;
        const float mvp[4][4] =
        {
            { 2.0f / (R - L),   0.0f,           0.0f,       0.0f },
            { 0.0f,         2.0f / (T - B),     0.0f,       0.0f },
            { 0.0f,         0.0f,           0.5f,       0.0f },
            { (R + L) / (L - R),  (T + B) / (B - T),    0.5f,       1.0f },
        };
        memcpy(&constant_buffer->mvp, mvp, sizeof(mvp));
        g_pD3D11DeviceContext->Unmap(g_pD3D11VertexConstantBuffer, 0);

        D3D11_VIEWPORT vp;
        vp.Width = g_context.io.displaySize.x;
        vp.Height = g_context.io.displaySize.y;
        vp.MinDepth = 0.0f;
        vp.MaxDepth = 1.0f;
        vp.TopLeftX = vp.TopLeftY = 0;
        g_pD3D11DeviceContext->RSSetViewports(1, &vp);

        UINT stride = 12;
        UINT offset = 0;
        g_pD3D11DeviceContext->IASetInputLayout(g_pD3D11InputLayout);
        g_pD3D11DeviceContext->IASetVertexBuffers(0, 1, &g_pD3D11VertexBuffer, &stride, &offset);
        g_pD3D11DeviceContext->IASetIndexBuffer(g_pD3D11IndexBuffer, sizeof(IndexType) == 2 ? DXGI_FORMAT_R16_UINT : DXGI_FORMAT_R32_UINT, 0);
        g_pD3D11DeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
        g_pD3D11DeviceContext->VSSetShader(g_pD3D11VertexShader, NULL, 0);
        g_pD3D11DeviceContext->PSSetShader(g_pD3D11PixelShader, NULL, 0);
        g_pD3D11DeviceContext->VSSetConstantBuffers(0, 1, &g_pD3D11VertexConstantBuffer);

        g_pD3D11DeviceContext->DrawIndexed(static_cast<UINT>(g_context.drawList.indices.size()), 0, 0);
    }
#endif

    static inline Vec2 operator+(const Vec2& first, const Vec2& second) { return Vec2(first.x + second.x, first.y + second.y); }
    static inline Vec2 operator-(const Vec2& first, const Vec2& second) { return Vec2(first.x - second.x, first.y - second.y); }

    static inline Vec2 operator*(const Vec2& first, const Vec2& second) { return Vec2(first.x * second.x, first.y * second.y); }
    static inline Vec2 operator*(const Vec2& first, const float second) { return Vec2(first.x + second, first.y - second); }

    bool IsPointInRect(const Vec4& rect, const Vec2& p)
    {
        return p.x >= rect.pos.x && p.x <= rect.pos.x + rect.size.x && p.y >= rect.pos.y && p.y <= rect.pos.y + rect.size.y;
    }

    void DrawList::AddRect(const Vec2& p1, const Vec2& p2, Color color, float rounding, uint32_t cornerFlags, float thickness)
    {
        if (!color.a || thickness == 0.0f)
            return;

        PathRect(p1 + Vec2(0.5f, 0.5f), p2 - Vec2(0.5f, 0.5f), rounding, cornerFlags);

        PathStroke(color, true, thickness);
    }

    void DrawList::AddRectFilled(const Vec2& p1, const Vec2& p2, Color color, float rounding, uint32_t cornerFlags)
    {
        if (!color.a)
            return;

        if (rounding > 0.0f)
        {
            PathRect(p1, p2, rounding, cornerFlags);
            PathFillConvex(color);
        }
        else
            PrimRect(p1, p2, color);
    }

    void DrawList::AddRectFilledMultiColor(const Vec2& p1, const Vec2& p2, Color colorUpperLeft, Color colorUpperRight, Color colorBottomRight, Color colorBottomLeft)
    {
        const size_t nextIndex = vertices.size();

        vertices.emplace_back(p1, colorUpperLeft, Vec2());
        vertices.emplace_back(Vec2(p2.x, p1.y), colorUpperRight, Vec2());
        vertices.emplace_back(p2, colorBottomRight, Vec2());
        vertices.emplace_back(Vec2(p1.x, p2.y), colorBottomLeft, Vec2());

        indices.push_back(nextIndex + 0);
        indices.push_back(nextIndex + 1);
        indices.push_back(nextIndex + 2);

        indices.push_back(nextIndex + 0);
        indices.push_back(nextIndex + 2);
        indices.push_back(nextIndex + 3);
    }

    void DrawList::AddQuad(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Vec2& p4, Color color, float thickness)
    {
        if (!color.a)
            return;

        PathLineTo(p1);
        PathLineTo(p2);
        PathLineTo(p3);
        PathLineTo(p4);
        PathStroke(color, true, thickness);
    }

    void DrawList::AddQuadFilled(const Vec2& p1, const Vec2& p2, const Vec2& p3, const Vec2& p4, Color color)
    {
        if (!color.a)
            return;

        PathLineTo(p1);
        PathLineTo(p2);
        PathLineTo(p3);
        PathLineTo(p4);
        PathFillConvex(color);
    }

    void DrawList::AddTriangle(const Vec2& p1, const Vec2& p2, const Vec2& p3, Color color, float thickness)
    {
        if (!color.a)
            return;

        PathLineTo(p1);
        PathLineTo(p2);
        PathLineTo(p3);
        PathStroke(color, true, thickness);
    }

    void DrawList::AddTriangleFilled(const Vec2& p1, const Vec2& p2, const Vec2& p3, Color color)
    {
        if (!color.a)
            return;

        const size_t nextIndex = vertices.size();
        vertices.emplace_back(p1, color, Vec2());
        vertices.emplace_back(p2, color, Vec2());
        vertices.emplace_back(p3, color, Vec2());
        for (size_t i = 0; i < 3; i++)
            indices.push_back(nextIndex + i);
    }

    void DrawList::AddCircle(const Vec2& p, float radius, Color color, size_t numSegments, float thickness)
    {
        if (!color.a || radius <= 0.0f)
            return;

        if (numSegments == 0)
            numSegments = (static_cast<size_t>(radius) - 1 < 64) ? sharedData->cachedCircleSegmentCounts64[static_cast<size_t>(radius) - 1] : CIRCLE_AUTO_SEGMENT_CALC(radius, 1.6f);
        else
            numSegments = Clamp(numSegments, static_cast<size_t>(3), static_cast<size_t>(CIRCLE_AUTO_SEGMENT_MAX));

        if (numSegments == 12)
            PathArcToCached(p, radius - 0.5f, 0, 12);
        else
            PathArcTo(p, radius - 0.5f, 0.0f, GUI_2PI * (static_cast<float>(numSegments - 1) / static_cast<float>(numSegments)), numSegments - 1);

        PathStroke(color, true, thickness);
    }

    void DrawList::AddCircleFilled(const Vec2& p, float radius, Color color, size_t numSegments)
    {
        if (!color.a || radius <= 0.0f)
            return;

        if (numSegments <= 0)
            numSegments = (static_cast<size_t>(radius) - 1 < 64) ? sharedData->cachedCircleSegmentCounts64[static_cast<size_t>(radius) - 1] : CIRCLE_AUTO_SEGMENT_CALC(radius, 1.6f);
        else
            numSegments = Clamp(numSegments, static_cast<size_t>(3), static_cast<size_t>(CIRCLE_AUTO_SEGMENT_MAX));

        if (numSegments == 12)
            PathArcToCached(p, radius, 0, 12);
        else
            PathArcTo(p, radius, 0.0f, GUI_2PI * ((static_cast<float>(numSegments) - 1.0f) / static_cast<float>(numSegments)), numSegments - 1);

        PathFillConvex(color);
    }

    void DrawList::AddNgon(const Vec2& center, float radius, Color color, size_t numSegments, float thickness)
    {
        if (!color.a || numSegments < 3)
            return;

        //Remove one(1) from numSegment because it's a closed shape.
        PathArcTo(center, radius - 0.5f, 0.0f, GUI_2PI * ((static_cast<float>(numSegments) - 1.0f) / static_cast<float>(numSegments)), numSegments - 1);
        PathStroke(color, true, thickness);
    }

    void DrawList::AddNgonFilled(const Vec2& center, float radius, Color color, size_t numSegments)
    {
        if (!color.a || numSegments < 3)
            return;

        //Remove one(1) from numSegment because it's a closed shape.
        PathArcTo(center, radius, 0.0f, GUI_2PI * ((static_cast<float>(numSegments) - 1.0f) / static_cast<float>(numSegments)), numSegments - 1);
        PathFillConvex(color);
    }

    void DrawList::PathRect(const Vec2& p1, const Vec2& p2, float rounding, uint32_t cornerFlags)
    {
        if (rounding <= 0.0f || cornerFlags == 0)
        {
            PathLineTo(p1);
            PathLineTo(Vec2(p2.x, p1.y));
            PathLineTo(p2);
            PathLineTo(Vec2(p1.x, p2.y));
        }
        else
        {
            const float roundingTopLeft = (cornerFlags & CORNER_FLAGS_TOP_LEFT) ? rounding : 0.0f;
            const float roundingTopRight = (cornerFlags & CORNER_FLAGS_TOP_RIGHT) ? rounding : 0.0f;
            const float roundingBottomRight = (cornerFlags & CORNER_FLAGS_BOTTOM_RIGHT) ? rounding : 0.0f;
            const float roundingBottomLeft = (cornerFlags & CORNER_FLAGS_BOTTOM_LEFT) ? rounding : 0.0f;
            PathArcToCached(Vec2(p1.x + roundingTopLeft, p1.y + roundingTopLeft), roundingTopLeft, 6, 9);
            PathArcToCached(Vec2(p2.x - roundingTopRight, p1.y + roundingTopRight), roundingTopRight, 9, 12);
            PathArcToCached(Vec2(p2.x - roundingBottomRight, p2.y - roundingBottomRight), roundingBottomRight, 0, 3);
            PathArcToCached(Vec2(p1.x + roundingBottomLeft, p2.y - roundingBottomLeft), roundingBottomLeft, 3, 6);
        }
    }

    void DrawList::PathArcTo(const Vec2& center, float radius, float startAngle, float endAngle, size_t numSegments, bool startAtCenter)
    {
        if (startAtCenter)
            path.push_back(center);

        for (size_t i = 0; i <= numSegments; i++)
        {
            const float angle = startAngle + (static_cast<float>(i) / static_cast<float>(numSegments)) * (endAngle - startAngle);
            path.emplace_back(center.x + cosf(angle) * radius, center.y + sinf(angle) * radius);
        }
    }

    void DrawList::PathArcToCached(const Vec2& center, float radius, size_t startAngleOf12, size_t endAngleOf12, bool startAtCenter)
    {
        if (startAtCenter)
            path.push_back(center);

        for (size_t angle = startAngleOf12; angle <= endAngleOf12; angle++)
        {
            const Vec2& point = sharedData->cachedCircleVertices12[angle % 12];
            path.emplace_back(center.x + point.x * radius, center.y + point.y * radius);
        }
    }

    void DrawList::PrimRect(const Vec2& p1, const Vec2& p2, Color color)
    {
        size_t nextIndex = vertices.size();

        vertices.emplace_back(              p1, color, Vec2());
        vertices.emplace_back(Vec2(p2.x, p1.y), color, Vec2());
        vertices.emplace_back(              p2, color, Vec2());
        vertices.emplace_back(Vec2(p1.x, p2.y), color, Vec2());

        indices.push_back(nextIndex + 0);
        indices.push_back(nextIndex + 1);
        indices.push_back(nextIndex + 2);

        indices.push_back(nextIndex + 0);
        indices.push_back(nextIndex + 2);
        indices.push_back(nextIndex + 3);
    }

    void DrawList::AddLine(const Vec2& p1, const Vec2& p2, Color color, float thickness)
    {
        if (!color.a)
            return;

        PathLineTo(p1 + Vec2(0.5f, 0.5f));
        PathLineTo(p2 + Vec2(0.5f, 0.5f));
        PathStroke(color, false, thickness);
    }

    void DrawList::AddPolyline(const Vec2* points, size_t numPoints, Color color, bool closed, float thickness)
    {
        if (numPoints < 2)
            return;

        size_t nextIndex = vertices.size();
        const float halfThickness = (thickness * 0.5f);
        for (size_t i = 0; i < (closed ? numPoints : numPoints - 1); i++, nextIndex += 4)
        {
            const Vec2& p1_tmp = points[i], &p2_tmp = points[(i + 1) == numPoints ? 0 : i + 1];
            const float dx = p2_tmp.x - p1_tmp.x;
            const float dy = p2_tmp.y - p1_tmp.y;

            //If we didn't swap the points in the cases the triangles would be drawn in the counter clockwise direction, which can cause problems in some rendering APIs.
            const bool swapPoints = (dx < 0.0f || dy < 0.0f) || (dx > 0.0f && dy > 0.0f);
            const Vec2& p1 = swapPoints ? p2_tmp : p1_tmp, & p2 = swapPoints ? p1_tmp : p2_tmp;

            if (dy == 0) // Horizontal line
            {
                int factor = dx > 0.0f ? 1 : -1;
                vertices.emplace_back(Vec2(p1.x - halfThickness * factor, p1.y - halfThickness), color, Vec2());
                vertices.emplace_back(Vec2(p2.x + halfThickness * factor, p2.y - halfThickness), color, Vec2());
                vertices.emplace_back(Vec2(p2.x + halfThickness * factor, p2.y + halfThickness), color, Vec2());
                vertices.emplace_back(Vec2(p1.x - halfThickness * factor, p1.y + halfThickness), color, Vec2());
            }
            else if (dx == 0) // Vertical line
            {
                int factor = dy > 0.0f ? 1 : -1;
                vertices.emplace_back(Vec2(p1.x + halfThickness, p1.y - halfThickness * factor), color, Vec2());
                vertices.emplace_back(Vec2(p2.x + halfThickness, p2.y + halfThickness * factor), color, Vec2());
                vertices.emplace_back(Vec2(p2.x - halfThickness, p2.y + halfThickness * factor), color, Vec2());
                vertices.emplace_back(Vec2(p1.x - halfThickness, p1.y - halfThickness * factor), color, Vec2());
            }
            else // Inclined line
            {
                const float lineWidth = sqrtf(dx * dx + dy * dy);

                const float cosine = dx / lineWidth;
                const float sine = dy / lineWidth;

                const float xFactor = cosine * halfThickness;
                const float yFactor = sine * halfThickness;

                vertices.emplace_back(Vec2(p1.x - yFactor, p1.y + xFactor), color, Vec2());
                vertices.emplace_back(Vec2(p2.x - yFactor, p2.y + xFactor), color, Vec2());
                vertices.emplace_back(Vec2(p2.x + yFactor, p2.y - xFactor), color, Vec2());
                vertices.emplace_back(Vec2(p1.x + yFactor, p1.y - xFactor), color, Vec2());
            }

            indices.push_back(nextIndex + 0);
            indices.push_back(nextIndex + 1);
            indices.push_back(nextIndex + 2);

            indices.push_back(nextIndex + 0);
            indices.push_back(nextIndex + 2);
            indices.push_back(nextIndex + 3);
        }
    }

    void DrawList::AddConvexPolyFilled(const Vec2* points, size_t numPoints, Color color)
    {
        if (numPoints < 3)
            return;

        const size_t nextIndex = vertices.size();
        for (size_t i = 0; i < numPoints; i++)
            vertices.emplace_back(points[i], color, Vec2());
        
        for (size_t i = 2; i < numPoints; i++)
            indices.push_back(nextIndex), indices.push_back(nextIndex + i - 1), indices.push_back(nextIndex + i);
    }

    Layer* GetLayer(IdentifierType layerId)
    {
        const bool isNewLayer = g_context.layers.find(layerId) == g_context.layers.end();
        Layer* newLayer = &g_context.layers[layerId];

        if (isNewLayer)
            g_context.layersStack.push_back(newLayer);

        return newLayer;
    }

    Layer* GetTopLayer() { return g_context.layersStack.back(); }
    Layer* GetBottomLayer() { return g_context.layersStack.front(); }
    Style* GetStyle(IdentifierType styleName) { return &g_context.styles[styleName]; }
    Context* GetContext() { return &g_context; }

    void Render()
    {
#ifdef _WIN32
        Win32NewFrame();
#endif
        g_context.drawList.vertices.clear(), g_context.drawList.indices.clear();

        bool mouseUpEvent = false;
        if (g_context.io.mouseUpQueue.size())
        {
            g_context.io.firstMouseUpEvent = &g_context.io.mouseUpQueue.front();
            mouseUpEvent = true;
        }
        else
            g_context.io.firstMouseUpEvent = nullptr;
        for (Layer* layer : g_context.layersStack)
            layer->Notify();
        if (mouseUpEvent)
            g_context.io.mouseUpQueue.pop();

        for (auto layer : g_context.layersStack)
        {
            if (layer->visible)
                layer->Render();
        }
    }

    void Widget::RegisterEventCallback(EVENT_TYPE eventType, void(*callback)(const Event&))
    {
        m_eventCallbacks.emplace_back(eventType, callback);
    }

    void Widget::UnregisterEventCallback(void(*callback)(const Event&))
    {
        for (size_t i = 0; i < m_eventCallbacks.size(); i++)
        {
            if (m_eventCallbacks[i].callback == callback)
            {
                m_eventCallbacks.erase(m_eventCallbacks.begin() + i);
                return;
            }
        }
    }

    void Widget::Notify()
    {
        wasMouseOver = mouseOver;
        mouseOver = IsPointInRect(rect, g_context.io.mousePos);
        for (auto& eventCallback : m_eventCallbacks)
        {
            switch (eventCallback.type)
            {
            case EVENT_MOUSE_HOVER:
                if (mouseOver)
                    eventCallback.callback(Event(EVENT_MOUSE_HOVER, this, g_context.io.mousePos, 0));
                break;
            case EVENT_MOUSE_ENTER:
                if (mouseOver && !wasMouseOver)
                    eventCallback.callback(Event(EVENT_MOUSE_ENTER, this, g_context.io.mousePos, 0));
                break;
            case EVENT_MOUSE_LEAVE:
                if (!mouseOver && wasMouseOver)
                    eventCallback.callback(Event(EVENT_MOUSE_ENTER, this, g_context.io.mousePos, 0));
                break;
            case EVENT_MOUSE_DOWN:
                for (int i = 0; i < 5; i++)
                {
                    if (g_context.io.mouseDown[i] && mouseOver)
                        eventCallback.callback(Event(EVENT_MOUSE_DOWN, this, g_context.io.mousePos, i));
                }
                break;
            case EVENT_KEY_DOWN:
                break;
            case EVENT_KEY_UP:
                break;
            default:
                if (g_context.io.firstMouseUpEvent && IsPointInRect(rect, g_context.io.firstMouseUpEvent->pos))
                {
                    if(eventCallback.type == EVENT_MOUSE_UP)
                        eventCallback.callback(Event(EVENT_MOUSE_UP, this, g_context.io.firstMouseUpEvent->pos, g_context.io.firstMouseUpEvent->key));
                    if (eventCallback.type == EVENT_MOUSE_CLICK)
                    {
                        if (IsPointInRect(rect, g_context.io.mouseClickedPos[g_context.io.firstMouseUpEvent->key]))
                            eventCallback.callback(Event(EVENT_MOUSE_CLICK, this, g_context.io.mousePos, 0));
                    }
                }
            }
        }
    }

    void Layer::MoveToTop(bool fixLayer)
    {
        size_t i = 0;
        for (; g_context.layersStack[i] != this; i++);

        for (size_t j = i; j < g_context.layersStack.size() - 1; j++)
            g_context.layersStack[j] = g_context.layersStack[j + 1];

        g_context.layersStack[g_context.layersStack.size() - 1] = this;
    }

    void Layer::MoveToBottom(bool fixLayer)
    {
        size_t i = 0;
        for (; g_context.layersStack[i] != this; i++);

        for (size_t j = i; j > 0; j--)
            g_context.layersStack[j] = g_context.layersStack[j - 1];

        g_context.layersStack[0] = this;
    }

    Button* Layer::AddButton(IdentifierType checkBoxId, const char* text, Style* style)
    {
        Button* button = new Button(this, text);
        button->RegisterEventCallback(EVENT_MOUSE_ENTER, [](const Event& e) {e.widget->backgroundColor = Gui::Color::Red; });
        button->RegisterEventCallback(EVENT_MOUSE_LEAVE, [](const Event& e) {e.widget->backgroundColor = Gui::Color::Blue; });
        return reinterpret_cast<Button*>(m_widgets[checkBoxId] = button);
    }

    CheckBox* Layer::AddCheckBox(IdentifierType checkBoxId, bool* checked)
    {
        return reinterpret_cast<CheckBox*>(m_widgets[checkBoxId] = new CheckBox(this, checked));
    }

    void Layer::Render()
    {
        for (auto& eventCallback : m_eventCallbacks)
        {
            if (eventCallback.type == EVENT_PRE_RENDER)
                eventCallback.callback(Event(EVENT_PRE_RENDER, this, Vec2(), 0));
        }

        g_context.drawList.AddRectFilled(rect.pos, rect.pos + rect.size, backgroundColor);

        for (auto& widget : m_widgets)
        {
            if (widget.second->visible)
            {
                for (auto& eventCallback : widget.second->GetEventCallbacks())
                {
                    if (eventCallback.type == EVENT_PRE_RENDER)
                        eventCallback.callback(Event(EVENT_PRE_RENDER, this, Vec2(), 0));
                }

                widget.second->Render();

                for (auto& eventCallback : widget.second->GetEventCallbacks())
                {
                    if (eventCallback.type == EVENT_POST_RENDER)
                        eventCallback.callback(Event(EVENT_POST_RENDER, this, Vec2(), 0));
                }
            }
        }

        for (auto& eventCallback : m_eventCallbacks)
        {
            if (eventCallback.type == EVENT_POST_RENDER)
                eventCallback.callback(Event(EVENT_POST_RENDER, this, Vec2(), 0));
        }
    };

    void Button::Render()
    {
        g_context.drawList.AddRectFilled(parent->rect.pos + rect.pos, parent->rect.pos + rect.pos + rect.size, backgroundColor, 6.0f);
    }

    void CheckBox::Render()
    {
    }

    bool IO::IsAnyMouseDown()
    {
        for (int i = 0; i < sizeof(mouseDown); i++)
        {
            if (mouseDown[i])
                return true;
        }

        return false;
    }

    void IO::AddInputCharacter(uint16_t c)
    {
        charatersQueue.push_back(c);
    }

    const Color Color::Black = Color(0, 0, 0, 255);
    const Color Color::White = Color(255, 255, 255, 255);
    const Color Color::Red = Color(255, 0, 0, 255);
    const Color Color::Green = Color(0, 255, 0, 255);
    const Color Color::Blue = Color(0, 0, 255, 255);
    const Color Color::Orange = Color(255, 165, 0, 255);
    const Color Color::Amber = Color(255, 191, 0, 255);
    const Color Color::AndroidGreen = Color(164, 198, 57, 255);
    const Color Color::Azure = Color(0, 127, 255, 255);
    const Color Color::Bronze = Color(205, 127, 50, 255);
    const Color Color::Corn = Color(251, 236, 93, 255);
    const Color Color::Emerald = Color(80, 200, 120, 255);
    const Color Color::LapisLazuli = Color(38, 97, 156, 255);
    const Color Color::Lava = Color(207, 16, 32, 255);

#endif // NMD_GUI_IMPLEMENTATION

};

#endif // NMD_GUI_H